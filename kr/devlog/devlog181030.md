# 개발로그 181030

## 오늘 배운 것 (1) - 웹과 네트워크 입문 - HTTP의 보안과 효율 개선 개요
HTTP의 보안상 한계: 헤더가 암호화되어있지 않고, 클라이언트/서버가 올바른지 확인할 수 없음

보안 연결을 위한 프로토콜: SSL(요즘은 TLS - Transport Layer Security) 등장.
HTTP과 TCP 연결 사이에 보안연결 세션을 만들어준다. HTTP + Secure = HTTPS!

### 암호화된 연결 개요 - 공개키와 공통키
공통키 : 클라이언트와 서버가 같은 키로 메시지를 암호화/복호화한다
=> 공통키의 문제: 키는 어떻게 안전하게 건네주지? - 공격자가 중간에 키를 보게되면 암호화의 의미가 없음

공개키 : 혹은 비대칭형 암호화. 암호화키(자물쇠)와 복호화키(열쇠)가 따로. 상대방에게는 암호화키만 제공하고, 메시지는 나만 가지고 있는 복호화키로 복원.
=> 공개키의 문제: 공개키를 주는 주체가 진짜인지 확인할 방법이 없음 - 제3자 인증기관(CA: Certificate Authority)을 통한 서버 공개키 인증
=> 불량 CA 때문에 문제가 생기기도: 2011년 DigiNorta 사건, 중국 CA의 절차 지키지 않은 인증서 발급
보통은 서버쪽 인증서를 사용하나, 클라이언트쪽 인증서를 요구하는 경우도 (=공인인증서)

편의 및 보안을 고려해 '폼 인증'(a.k.a 로그인) 을 더하거나 얘만 이용하거나. 

### HTTP의 비효율 - 병목현상
- 한 번에 하나의 연결만 가능하고 리퀘스트/리스폰스도 한번에 하나씩만 전송 가능
- 리스폰스에 콘텐츠 전체, 혹은 전체 콘텐츠를 바이트 단위로 쪼갠 청크만 담을 수 있음
- 그리고 서버에서 갱신된 내용을 클라이언트에서 확인하려면 매번 갱신 리퀘스트를 보내야 함

**Ajax의 등장**
페이지 일부분만 리퀘스트할 수 있어서 전체 콘텐츠를 갱신하는 수고 불필요. 하지만 병목현상 해결책은 아님

**Google의 SPDY** (이후 마소와 다른 기관들의 신기술을 이것저것 더해서 HTTP/2로 성장함)
- 커넥션을 열어둔 채로 서버와 다중 연결.
- 서버에서 클라이언트로 푸시 가능 (리퀘스트 없어도 데이터를 전송할 수 있게 됨)

**웹소켓**
- HTTP 아래에서 기능하는 별도의 프로토콜
- (SPDY와 차이점) '페이지/앱이 열려있을 때' 서버와 양방향 실시간 통신

### 그 외 개념들
**동적 / 정적 HTML?**
- 웹서버가 리스폰스 콘텐츠(=엔티티?)를 생성하는 구조 (CGI: Common Gateway Interface)
  * CGI 프로그램들: PHP, Perl, Ruby (아하~)
  * 리퀘스트가 들어올 때 마다 웹 서버 밖의 프로그램을 실행해야 하기 때문에 웹 서버 자원 소모와 병목현상이 생길 수도
    => 이 문제의 대안으로 자바가 소개한 '서블릿Servlet' 개념 등장. CGI 프로그램을 따로 실행하지 않고, 웹 서버 프로세스 안에서 동적 콘텐츠 생성을 (스레드로) 처리
    +@: 프로세스보다 스레드가 나은 이유, 애시당초 그 둘의 차이는? > http://ralf79.tistory.com/34 

**XML**
HTML과 비슷한 마크업 언어. 데이터를 표현하는 데 최적화되어 애플리케이션 사이 데이터 교환에 많이 쓰임 (RSS 정보를 전달하는 언어가 XML. 아하!)

**JSON**
XML이 행복하게 살아왔는데, ECMAScript가 대두하면서 JSON 사용이 늘어나는 추세


### 웹 환경에서의 보안 이슈
HTTP 위에서는
- 중간자 공격(클라이언트나 서버로 위장해 둘 사이 통신에 끼어듬)
- 인젝션: 클라이언트나 서버쪽에 HTTP 리퀘스트를 보내는 함정을 깔고, 해당 함정이 발동되면 정상 리퀘스트인 척 꾸미거나 해커의 서버로 정보를 탈취

HTML 위에서는
- 인젝션 (위와 같음. URL 리다이렉션, 폼을 이용한 JavaScript/SQL 삽입 등을 이용)
- 클릭 재킹: 투명도(Opacity)와 frame(+XSS: Cross Site Scripting)을 이용



## 오늘 배운 것 (2) - 알고리즘: 동적 계획법
어제 고민하던 1문제 손쉽게 해결.
마무리하고 나니 코드가 평소보다 길어서 문제 난이도가 잘못 잡힌 경우인가 생각했는데,
통과 후 다른 분들의 코드를 보니 아, 내 잘못이었다.

같은 로직을 더 읽기 쉽고 짧게 구현한 사례가 있더라. 문제 풀이에 압도당해서 풀이를 완성한 뒤 리팩토링까지는 생각이 미치지 못했다.

(그래도, 알고리즘에는 리팩토링을 너무 신경쓰지 않아도 된다고 하니 안심이다.)
다음에 비슷한 문제를 풀 때는 방법을 깨우쳤으니 흡수한 모범 답안을 이용해 빠르고 효율적으로 풀어치우자.